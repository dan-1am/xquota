#!/usr/bin/env python

version = '1.05'
created = '2023.06.17'

import re
import sys
import os
from pathlib import Path
import subprocess
import pwd
from time import sleep
from datetime import datetime,date,time,timedelta
import logging,logging.handlers



appname = sys.argv[0].rpartition('/')[2]
debug = 0
conffile='/usr/local/etc/xquota.conf'
statefile='/var/tmp/xquota.state'
logfile='/var/log/xquota.log'

if debug:
    conffile = conffile.rpartition('/')[2]
    statefile = statefile.rpartition('/')[2]
    logfile = logfile.rpartition('/')[2]

savedelay = 5 if debug else 300
watchdelay = 1 if debug else 15



################ logging

def startlog():
    global log
    global consolelog
    log = logging.getLogger()
    log.setLevel(logging.DEBUG)

    consolelog = logging.StreamHandler()
    fmt = logging.Formatter('%(levelname)s: %(message)s')
    consolelog.setFormatter(fmt)
    log.addHandler(consolelog)

    filelog = logging.handlers.RotatingFileHandler(logfile, maxBytes=pow(10,6), backupCount=1)
    fmt = logging.Formatter('%(asctime)s %(levelname)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
    filelog.setFormatter(fmt)
    log.addHandler(filelog)


def daemonlog():
    if debug: return
    syslog = logging.handlers.SysLogHandler(address = '/dev/log')
    fmt = logging.Formatter(appname + ': %(levelname)s: %(message)s')
    syslog.setFormatter(fmt)
    syslog.setLevel(logging.ERROR)
    log.addHandler(syslog)
    log.removeHandler(consolelog)



################ tests

tests_list = []

def tests(func):
    tests_list.append(func)
    return func


def tests_run():
    for t in tests_list:
        t()
    print("Tests finished.")



################ bash commands

def notify(txt):
    try:
        subprocess.run(['notify-send', txt])
    except FileNotFoundError:
        log.warning('notify-send not found, can not send warnings.')

def notifyuser(user, txt):
    try:
        uid0 = os.geteuid()
        uid = userid(user)      #todo: use uid instead of user
        log.info(f'switching to {uid=}')
        os.seteuid(uid)
        env = {'DISPLAY':':0'}
        for k in 'PATH','HOME':
            env[k] = os.environ[k]
        subprocess.run(['notify-send', txt],env=env)
        os.seteuid(uid0)
    except PermissionError:
        log.error('need root to notify other users.')
    except FileNotFoundError:
        #todo: test existence of notify-send
        log.warning('notify-send not found, can not send warnings.')



################ process list

def userid(name):
    return pwd.getpwnam(name).pw_uid


def kill(pid):
    log.info(f'Killing {pid}')
    if not debug:
        os.kill(pid, 15)        #15=term


def psfullname(procdir):
    try:
        with open(procdir / 'cmdline') as f:
            args = f.read()
            return args.partition('\x00')[0]
    except OSError:
        pass


class process:
    def __init__(self, procdir):
        self.procdir = procdir
        self.pid = int(procdir.name)
        self.fullname = psfullname(procdir)
        self.name = self.fullname.rpartition('/')[2]

    def uid(self):
        uid = getattr(self,'_uid',None)
        if uid != None:
            return uid
        try:
            with open(self.procdir / 'loginuid') as f:
                self._uid = int( f.read() )
                return self._uid
        except OSError:
            pass

    def exists(self):
        return self.procdir.exists()


def psiterate():
    for ps in Path('/proc').iterdir():
        if ps.name.isdigit() and ps.is_dir():
            yield process(ps)


def killall(pslist):
    for ps in pslist:
        try:
            kill(ps.pid)
        except ProcessLookupError:
            pass


@tests
def test_ps():
    count = 0
    for ps in psiterate():
        count += 1
        if ps.name == 'login':
            break
    else:
        raise Exception('no login process found')
    assert count > 0, 'empty ps list'



################ date


datechars = set('0123456789.')
timechars = set('0123456789:')

def parsedate(txt, now=None):
    if not now:
        now = date.today()
    if txt.isdigit():
        if len(txt) <= 2:
            return date( now.year, now.month, int(txt) )
        if len(txt) == 4:
            return date( now.year, int(txt[:2]), int(txt[2:]) )
        if len(txt) == 6:
            return date( int(str(now.year)[0:2]+txt[:2]), int(txt[2:4]), int(txt[4:]) )
    elif set(txt) <= datechars:
        if len(txt) == 5:
            return date( now.year, int(txt[:2]), int(txt[3:]) )
        if len(txt) == 8:
            return date( int(str(now.year)[:2]+txt[:2]), int(txt[3:5]), int(txt[6:]) )
        if len(txt) == 10:
            return date( int(txt[:4]), int(txt[5:7]), int(txt[8:]) )



def parsetime(txt):
    if txt.isdigit():
        if len(txt) == 4:
            return time( int(txt[:2]), int(txt[2:]), 0 )
        if len(txt) == 6:
            return time( int(txt[:2]), int(txt[2:4]), int(txt[4:]) )
    elif set(txt) <= timechars:
        if len(txt) == 5:
            return time( int(txt[:2]), int(txt[3:]), 0 )
        if len(txt) == 8:
            return date( int(txt[:2]), int(txt[3:5]), int(txt[6:]) )



################ rules

class rule:
    def __init__(self, start, add, end, ruleid):
        self.start = start
        self.add = add
        self.end = end
        self.id = ruleid
        self.spent = 0

    def spend(self,sec):
        global statechanged
        self.spent += sec/60
        statechanged = True

    def ended(self):
        return self.spent >= self.add

    def __repr__(self):
        start = self.start.strftime('%Y.%m.%d %H:%M')
        end = self.end.strftime('%Y.%m.%d %H:%M')
        return f'{start} - {end} +{self.spent}/{self.add}'



################ parserules

users = {}


def parserules(txt):

    def users(*names):
        global users
        for name in names:
            users[ userid(name) ] = name

    def sub(add, day=None):
        nonlocal totalsub
        if(not day or parsedate(day, datenow) == datenow):
            totalsub += add

    def add(start, add, maxadd=0, day=None):
        nonlocal rules, totalsub
        if(day):
            day = parsedate(day, datenow)
            if day != datenow:
                return
        else:
            day = datenow
        left = add
        if totalsub:
            if totalsub >= add:
                totalsub -= add
                return
            else:
                left -= totalsub
                totalsub = 0
        start = datetime.combine(day, parsetime(start))
        if maxadd:
            end = start + timedelta(minutes=maxadd)
        else:
            end = start + timedelta(minutes=left)
        ruleid = f'{start.isoformat()}+{add}'
        rules.append( rule(start, left, end, ruleid) )

    now = datetime.now()
    datenow = now.date()
    rules = []
    totalsub = 0
    exec(txt)
    return rules


def newrules():
    global rules
    rules = parserules(rulestext)
    rules.sort(key=lambda r: r.end)


def activerule(time, rules):
    for r in rules:
        if time >= r.start and time < r.end:
            if r.spent < r.add:
                return r


def displayrules():
    active = activerule(datetime.now(), rules)
    for r in rules:
        if r == active:
            print('> ', end='')
        print(r)



################ conf file

confloadedat = None
rulestext = ''


def confreload():
    global confloadedat,rulestext
    name = conffile
    try:
        with open(name) as f:
            txt = f.read()
    except OSError:
        log.error(f'unable to load configuration from [{name}]')
    else:
        if txt != rulestext:
            log.info(f'Configuration loaded from [{name}]')
            rulestext = txt
            confloadedat = datetime.now()
            return True



################ save state

statechanged = False
savestatelast = None

def statesaved(now=None):
    global statechanged,savestatelast
    if not now:
        now = datetime.now()
    statechanged = False
    savestatelast = now


def savestate(force=False):
    if not (force or statechanged):
        return
    now = datetime.now()
    if force or savestatelast and (now-savestatelast).total_seconds() > savedelay:
        state = ''
        for r in rules:
            if r.spent > 0:
                state += f'{r.id}={r.spent:.2f}\n'
        log.info('Saving state.')
        try:
            with open(statefile, 'w') as f:
                f.write(state)
        except OSError:
            log.error(f'unable to save state to [{statefile}]')
        else:
            statesaved(now)


def loadstate():
    statesaved()
    try:
        with open(statefile) as f:
            txt = f.read()
    except FileNotFoundError:
        return
    log.info('State loaded.')
    state = {}
    for line in txt.splitlines():
        ruleid,_,spent = line.partition('=')
        state[ruleid] = float(spent)
    for r in rules:
        spent = state.get(r.id)
        if spent:
            r.spent = spent



################ watch

def pscheck():
    found = []
    for ps in psiterate():
        if ps.name == 'X':
            uid = ps.uid()
            if uid in users:
                return True


def control():
    found = []
    for ps in psiterate():
        if ps.name == 'X':
            uid = ps.uid()
            if uid in users:
                found.append(ps)
                notifyuser(users[uid], 'Ограничение по времени, выход в консоль через 30 секунд.')
    if found:
        sleep(30)
        killall(found)


def daemon():
    log.info('Daemon started.')
    now = datetime.now()
    lastrule = None
    newrules()
    loadstate()
    while True:
        last,now = now,datetime.now()
        if confreload() or last.day != now.day:
            lastrule = None
            newrules()
        if not lastrule or lastrule.ended():
            lastrule = activerule(now, rules)
        if lastrule:
            if pscheck():
                dt = (now-last).total_seconds()
                lastrule.spend(dt)
        else:
            control()
        savestate()
        sleep(watchdelay)



################ main

def showhelp():
    print('''\
Display current rules:
xquota

Run daemon as root:
xquota -d''')



def main():
    startlog()
#    asroot = os.getuid() == 0
    if debug:
        tests_run()
    if len(sys.argv) > 1:
        if sys.argv[1] == '-d':
            daemonlog()
            if not confreload(): return
            daemon()
        else:
            print('Wrong arguments.\n')
            showhelp()
            return
    else:
        if not confreload(): return
        newrules()
        loadstate()
        displayrules()


try:
    main()
except Exception:
    log.critical('Exception in main', exc_info=True)
    sys.exit(1)
